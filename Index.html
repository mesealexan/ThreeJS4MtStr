<!DOCTYPE html>
<html lang="en">
<head>
<style>
body {
	font-family: Monospace;
	background-color: #F5F5F5;
	margin: 0px;
	overflow: hidden;
}

#container {
position: fixed;
height: 100%;
width: 100%;
}
#text{
	top:10px;
	left: 20px;
	color: #000;
	position: fixed;
	z-index: 100;
}
#local{
	left: 200px;
	top:10px;
	color: #000;
	position: fixed;
	z-index: 100;
}
#downloadLink{
	position: fixed;
	top:10px;
	left: 400px;
	z-index: 100;
}
</style>

<script src="lib/jquery-1.8.3.min.js"></script>

<script src="lib/three.min.js"></script> 
<!-- 
<script src="three.min.js"></script> 
<script src="scripts/libs/threejs/three.min.js"></script> 
-->

<script src="lib/Detector.js"></script>
<script src="lib/Coordinates.js"></script>
<script src="lib/OrbitAndPanControls.js"></script>
<script src="lib/TrackballControls.js"></script>
<script src="lib/uclass_TeapotGeometry.js"></script>
<script src="lib/uclass_TeacupGeometry.js"></script>
<script src="lib/uclass_TeaspoonGeometry.js"></script>
<script src="lib/uclass_BeveledBlockGeometry.js"></script>
<script src="lib/uclass_shaders.js"></script>
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/tween.min.js"></script>
<script src="lib/sprintf.js"></script>


</head>
<body>
<div id="container"></div>	
<div id="text"><b>Select Object</b><br> <u>World</u><br> X: <br> Y:<br> Z:</div>	
<div id="local"> <u>Local</u><br> X: <br> Y:<br> Z:</div>
<button id="downloadLink" onclick="createText()">XML</button>
</a>
<script>
////////////////////////////////////////////////////////////////////////////////
// Robot hand exercise: add a second grabber and have it respond
////////////////////////////////////////////////////////////////////////////////
/*global THREE, Coordinates, $, document, window, dat*/


//Opens a new window with all the positions of all objects
function createText(){
var childWindowName = open('coordinates.xml','childWindowName','properties of window');
childWindowName.document.bgColor='000000';
if(ray_objects)
	for(i=0;i<ray_objects.length;i++){
		var vector = new THREE.Vector3();
		childWindowName.document.write(
			"<h" + i+1 + "style='font-size:16px'><b>" + ray_objects[i].name + "</b><hr>" +
				"<u>  World</u><br>" +
				"   X:" + vector.getPositionFromMatrix( ray_objects[i].matrixWorld ).x + "<br>" +
				"   Y:" + vector.getPositionFromMatrix( ray_objects[i].matrixWorld ).y + "<br>" +
				"   Z:" + vector.getPositionFromMatrix( ray_objects[i].matrixWorld ).z + "<br>" +
				"<u>  Local</u><br>" +
				"   X:" + ray_objects[i].position.x + "<br>" +
				"   Y:" + ray_objects[i].position.x + "<br>" +
				"   Z:" + ray_objects[i].position.x + "<br><br><br>" )
	}
}




var camera, scene, renderer;
var cameraControls, effectController;
var clock = new THREE.Clock();
var gridX = true;
var gridY = false;
var gridZ = false;
var axes = true;
var ground = true;
var arm, forearm, body, handLeft, handRight,object;
var axis;
var world_text, local_text;
//Variables for raycaster
var projector = new THREE.Projector(), 
    mouse_vector = new THREE.Vector3(),
    mouse = { x: 0, y: 0, z: 1 },
    ray = new THREE.Raycaster( new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0) );
    intersects = []; 

//Sections properties (to be read from SQL)
var I_d = 23.6, I_bf = 7.01, I_T = 20.75, I_tw = 0.395, I_tf = 0.505, I_k1 = 1;
var L_d = 5, L_b = 3.5, L_xbar = 0.854, L_ybar = 1.6, L_t = 0.375;
var Pipe_OD =8.625 , Pipe_tnom = 0.322;

//Create an empty array that will hold all the geometry for picking
var ray_objects = [];
var box_pivot;

function fillScene() {
	scene = new THREE.Scene();
	scene.fog = new THREE.Fog( 0x808080, 2000, 4000 );
var material = new THREE.LineBasicMaterial({
        color: 0x0000ff
    });

	// LIGHTS
	var ambientLight = new THREE.AmbientLight( 0x222222 );
	var light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
	light.position.set( 200, 400, 500 );
	var light2 = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
	light2.position.set( -500, 250, -200 );
	scene.add(ambientLight);
	scene.add(light);
	scene.add(light2);

	// Robot definitions
	var robotHandLeftMaterial  = new THREE.MeshPhongMaterial( { color: 0xCC3399, specular: 0xCC3399, shininess: 20 } );
	var robotHandRightMaterial = new THREE.MeshPhongMaterial( { color: 0xDD3388, specular: 0xDD3388, shininess: 20 } );
	var robotBaseMaterial      = new THREE.MeshPhongMaterial( { color: 0x6E23BB, specular: 0x6E23BB, shininess: 20 } );
	var robotForearmMaterial   = new THREE.MeshPhongMaterial( { color: 0xF4C154, specular: 0xF4C154, shininess: 100 } );
	var robotUpperArmMaterial  = new THREE.MeshPhongMaterial( { color: 0x95E4FB, specular: 0x95E4FB, shininess: 100 } );

	// Step#1: to create the objects from root to op
	ExArm = new THREE.Object3D();
	ExArm.name = "ExArm"
	ExArm.Length = 50;
	createMbr( ExArm, drawSection('L','W44X335') , ExArm.Length , robotHandLeftMaterial );


	HangPipe = new THREE.Object3D();
	HangPipe.name = "HangPipe"
	HangPipe.Length = 120;
	createMbr( HangPipe,drawSection('I','W44X335') ,HangPipe.Length , robotHandRightMaterial );

	MtPipe = new THREE.Object3D();
	MtPipe.name = "MtPipe"
	MtPipe.Mbr1Length = 120;
	createMbr( MtPipe, drawSection('Pipe','W44X335'), MtPipe.Mbr1Length , robotForearmMaterial );

	
	MtPipeB = new THREE.Object3D();
	MtPipeB.name = "MtPipeB"
	createMbr( MtPipeB, drawSection('Pipe','W44X335'), MtPipe.Mbr1Length , robotUpperArmMaterial );


	box = new THREE.Object3D();
	MtPipeB.name = "box"
	createMbr( box, drawSection('Pipe','W44X335'), 80 , robotUpperArmMaterial );

	box_pivot = new THREE.Object3D();
	box_pivot.position.copy(MtPipeB.position);
	box_pivot.add(box)
	MtPipeB.add( box_pivot );
	box.position.x = -15;
	
	box.position.z = 40;
	box.rotation.y = 5 * Math.PI/180;	
	box.rotation.z = 30 * Math.PI/180;	

		

		MtPipe.rotation.x = Math.PI/2;
		MtPipe.position.x = -Pipe_OD - L_b;

		MtPipeB.rotation.x = Math.PI/2;
		MtPipeB.position.x = -Pipe_OD - L_b;
	HangPipe.add(MtPipe);
	HangPipe.add(MtPipeB);
		HangPipe.rotation.y = Math.PI/2
		HangPipe.position.x = -HangPipe.Length/2
		HangPipe.position.z = ExArm.Length;
	ExArm.add(HangPipe);
		ExArm.rotation.y = Math.PI;
	scene.add( ExArm );

		axis = new THREE.AxisHelper(75);
		axis.position.set(0,0,0)
		scene.add(axis); 
}
function createMbr(object, shape, height, material){
	var geometry = new THREE.ExtrudeGeometry( shape, {bevelEnabled: false, amount:height} );
	geometry.computeFaceNormals()
	var mesh = new THREE.Mesh( geometry, material );
	object.add(mesh);  
	mesh.name = object.name.toString();
	//mesh.name = object.toString();
	ray_objects.push(mesh) //Push all the geometry in the array for later picking
}
//Example of usage   drawI(23.6,7.01,20.75,0.395,0.505,1)

function drawSection(shapeType,shapeSize){
	if(shapeType === "I")
		return(drawI(I_d,I_bf,I_T,I_tw,I_tf,I_k1))
	if(shapeType === "L")
		return(drawL(L_d,L_b,L_xbar,L_ybar,L_t))
	if(shapeType === "Pipe")
		return(drawPipe(Pipe_OD,Pipe_tnom))
}

function drawI(d,bf,T,tw,tf,k1){
	var shape = new THREE.Shape();
	shape.moveTo(-bf/2, -d/2);
	shape.lineTo(bf/2, -d/2);
	shape.lineTo(bf/2, -d/2 + tf);
	shape.lineTo(k1, -d/2 + tf);
	shape.lineTo(tw/2, -T/2);
	shape.lineTo(tw/2, T/2);
	shape.lineTo(k1, d/2 - tf); 
	shape.lineTo(bf/2, d/2 - tf);
	shape.lineTo(bf/2, d/2);
	shape.lineTo(-bf/2, d/2);
	shape.lineTo(-bf/2, d/2 - tf);
	shape.lineTo(-k1, d/2 - tf);
	shape.lineTo(-tw/2, T/2);
	shape.lineTo(-tw/2, -T/2);
	shape.lineTo(-k1, -d/2 + tf);
	shape.lineTo(-bf/2, -d/2 + tf);
	shape.lineTo(-bf/2, -d/2);
	return(shape);
}

//Example of usage   drawPipe(8.625,0.322)
function drawPipe(OD,tnom){
	var arcShape = new THREE.Shape();
    arcShape.absarc( 0, 0, OD, 0, Math.PI*2, true );

	var holePath = new THREE.Path();
    holePath.absarc(0, 0, OD-tnom, 0, Math.PI*2, false );
    arcShape.holes.push( holePath );
return(arcShape);
}

//Example of usage   drawL(5,3.5,0.854,1.6,0.375)
function drawL(d,b,xbar,ybar,t){
	var shape = new THREE.Shape();
	shape.moveTo(-xbar,d-ybar);
	shape.lineTo(-xbar+t,d-ybar-t);
	shape.lineTo(-xbar+t,-ybar+t+t);
	shape.lineTo(-xbar+t+t,-ybar+t);
	shape.lineTo(-xbar+b-t,-ybar+t);
	shape.lineTo(-xbar+b,-ybar);
	shape.lineTo(-xbar,-ybar);
	shape.lineTo(-xbar,d-ybar);
	return(shape);
}

function init() {
	var canvasWidth = screen.width; // 846;
	var canvasHeight = screen.height; // 494;
	// For grading the window is fixed in size; here's general code:
	//var canvasWidth = window.innerWidth;
	//var canvasHeight = window.innerHeight;
	var canvasRatio = canvasWidth / canvasHeight;

	// RENDERER
	renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
	renderer.gammaInput = true;
	renderer.gammaOutput = true;
	renderer.setSize(canvasWidth, canvasHeight);
	renderer.setClearColorHex( 0xAAAAAA, 1.0 );
	renderer.domElement.addEventListener( 'mousedown', onMouseDown, false );
	// CAMERA
	camera = new THREE.PerspectiveCamera( 38, canvasRatio, 1, 10000 );
	// CONTROLS
	cameraControls = new THREE.OrbitAndPanControls(camera, renderer.domElement);
	camera.position.set(-490, 242,54);
	cameraControls.target.set(54, 106, 33);
	fillScene();

}

function addToDOM() {
	var container = document.getElementById('container');
	var canvas = container.getElementsByTagName('canvas');
	if (canvas.length>0) {
		container.removeChild(canvas[0]);
	}
	container.appendChild(renderer.domElement );
}

function drawHelpers() {
	if (ground) {
		Coordinates.drawGround({size:10000});
	}
	if (gridX) {
		Coordinates.drawGrid({size:10000,scale:0.01});
	}
	if (gridY) {
		Coordinates.drawGrid({size:10000,scale:0.01, orientation:"y"});
	}
	if (gridZ) {
		Coordinates.drawGrid({size:10000,scale:0.01, orientation:"z"});
	}
	if (axes) {
		Coordinates.drawAllAxes({axisLength:200,axisRadius:1,axisTess:50});
	}
}
function onMouseDown( event_info ) 
		{

		event_info.preventDefault();  
	    mouse.x = ( event_info.clientX / screen.width ) * 2 - 1;
	    mouse.y = - ( event_info.clientY / screen.height ) * 2 + 1;	
	    mouse_vector.set( mouse.x, mouse.y, mouse.z );
    	projector.unprojectVector( mouse_vector, camera );
		var direction = mouse_vector.sub( camera.position ).normalize();
   		ray.set( camera.position, direction );
   		intersects = ray.intersectObjects(ray_objects, false );
   		    if(intersects.length>0)
   		    {
   		    	var vector = new THREE.Vector3();
   		    	console.log(vector.getPositionFromMatrix( intersects[0].object.matrixWorld ));
   		    	axis.position.x = vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).x;
   		    	axis.position.y = vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).y;
   		    	axis.position.z = vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).z;
   		    	world_text = document.getElementById("text").innerHTML = 
   		    	intersects[0].object.name + '<br>' + '<u>World</u> <BR>' +
   		    	'X: ' + vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).x + '<br>' +  
   		    	'Y: ' + vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).y + '<br>' + 
   		    	'Z: ' + vector.getPositionFromMatrix( intersects[0].object.matrixWorld ).z;
   		    	local_text = '<u>Local</u> <BR>' +
   		    	'X: ' +  intersects[0].object.position.x + '<br>' +  
   		    	'Y: ' + intersects[0].object.position.y + '<br>' + 
   		    	'Z: ' + intersects[0].object.position.z
   		    	document.getElementById("text").innerHTML = world_text;
   		    	document.getElementById("local").innerHTML = local_text;
   		    	
   		    }
		}
function animate() {
	window.requestAnimationFrame(animate);
	render();
}

function render() {
	var delta = clock.getDelta();
	cameraControls.update(delta);

	if ( effectController.newGridX !== gridX || effectController.newGridY !== gridY || effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes)
	{
		gridX = effectController.newGridX;
		gridY = effectController.newGridY;
		gridZ = effectController.newGridZ;
		ground = effectController.newGround;
		axes = effectController.newAxes;

		//fillScene(); <- don't see the point for this
		drawHelpers();
	}


	
	
// mPipeAllV: 0,
MtPipe.position.y = effectController.mPipeAllV*MtPipe.Mbr1Length + MtPipe.Mbr1Length/2;
MtPipeB.position.y = effectController.mPipeAllV*MtPipe.Mbr1Length + MtPipe.Mbr1Length/2;

MtPipe.position.z  = effectController.mPipeAH*HangPipe.Length + HangPipe.Length/2;
MtPipeB.position.z = effectController.mPipeBH*HangPipe.Length + HangPipe.Length/2;
HangPipe.position.x = effectController.HArmHO*HangPipe.Length - HangPipe.Length/2;

// mPipeAH:0.35,
// mPipeBH:-0.35,
// HArmHO:0,
// EArmVO:0,
ExArm.position.y = effectController.EArmVO*100 + 20;

ExArm.rotation.y = effectController.EArmHR * Math.PI/180 + Math.PI;		
	
	renderer.render(scene, camera);
}

function setupGui() {

	effectController = {

newGridX: gridX,
newGridY: gridY,
newGridZ: gridZ,
newGround: ground,
newAxes: axes,



mPipeAllV: 0,
mPipeAH:0.35,
mPipeBH:-0.35,
HArmHO:0,
EArmVO:0,
EArmHR:0

	};

	var gui = new dat.GUI();
	
	var h = gui.addFolder("Grid display");
	h.add( effectController, "newGridX").name("Show XZ grid");
	h.add( effectController, "newGridY" ).name("Show YZ grid");
	h.add( effectController, "newGridZ" ).name("Show XY grid");
	h.add( effectController, "newGround" ).name("Show ground");
	h.add( effectController, "newAxes" ).name("Show axes");
	

	
	h = gui.addFolder("Mounting Structure");
	h.add(effectController, "mPipeAllV", -0.5, 0.5, 0.01).name("mPipes Vertical");
	h.add(effectController, "mPipeAH", -0.5, 0.5, 0.01).name("mPipe A Horizontal");
	h.add(effectController, "mPipeBH", -0.5, 0.5, 0.01).name("mPipe B Horizontal");
	h.add(effectController, "HArmHO", -0.5, 0.5, 0.01).name("H Arm Hori Offset");
	h.add(effectController, "EArmVO", -0.5, 0.5, 0.01).name("Extend Arm Vert Offset");
	h.add(effectController, "EArmHR", -180.0, 180.0, 0.025).name("Extend Arm Hori Rot");
	
}

try {
	init();
	//fillScene(); <- don't see the point for this
	drawHelpers();
	addToDOM();
	setupGui();
	animate();
} catch(e) {
	var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
	$('#container').append(errorReport+e);
}

</script>
</body>

</html>
